/**
 * 插入排序本质: 每次拎出一个元素，插入到已排序序列的合适位置
 * 两层循环，外层遍历未排序序列，内层遍历已排序序列，找合适的位置插入
 * 处理小规模或部分有序数据时，表现较好。当数据规模较大时，性能下降
 */
function insertSort(arr) {
    // 从数组的第二个元素开始遍历
    for (let i = 1; i < arr.length; i++) {
        let j = i; // 追踪当前元素位置
        let temp = arr[i]; // 保存当前元素的值

        // 从后向前扫描已排序序列，找到合适的位置插入当前元素
        while (j > 0 && arr[j - 1] > temp) {
            arr[j] = arr[j - 1]; // 将已排序序列中的元素向后移动一位
            j--; // 继续向前扫描
        }

        // 将当前元素插入到合适的位置
        arr[j] = temp;
    }

    // 返回排序后的数组
    return arr;
}

// 测试
let arr = [5, 3, 8, 4, 4, 2, 0, 1];
console.log(insertSort(arr)); // [0, 1, 2, 3, 4, 5, 8]

/*
* 时间复杂度：O(n^2)
*   最好情况 O(n)：有序, 每次插入都不需要移动
*   最坏情况 O(n^2)：逆序，每次插入都需要将以排序数组的元素向后移动
* 空间复杂度：O(1), 原地排序算法，不需要额外的存储空间，但还需要一个常数级的临时变量temp
*/